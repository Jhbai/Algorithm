# **LeetCode 88\. Merge Sorted Array 題目解析**

這是一道非常經典的陣列處理題目，主要考察對陣列操作、指標運用以及空間複雜度的理解。

## **1\. 題目敘述**

給定兩個按 **非遞減順序**（Non-decreasing order）排列的整數陣列 nums1 和 nums2，另有兩個整數 m 和 n，分別表示 nums1 和 nums2 中的有效元素數目。

**要求：**

* 將 nums2 合併到 nums1 中，使合併後的 nums1 同樣按非遞減順序排列。  
* **注意：** 最終合併後的陣列不應由函數返回，而是必須 **原地（In-place）** 修改 nums1。  
* 為了容納合併後的元素，nums1 的初始長度為 $m \+ n$，其中前 $m$ 個元素是有效數字，後 $n$ 個元素被設為 $0$（僅作為占位符）。

## **2\. 測驗目的**

這道題目主要測試以下能力：

1. **陣列基本操作**：如何在不使用額外空間的情況下移動元素。  
2. **雙指標（Two Pointers）技巧**：如何高效地遍歷兩個有序序列。  
3. **逆向思考能力**：從後往前填充陣列，避免覆蓋尚未處理的有效數據。  
4. **時間與空間複雜度優化**：能否達到時間複雜度 $O(m+n)$ 且空間複雜度 $O(1)$。

## **3\. 思路邏輯分析**

### **直覺做法（暴力法）**

將 nums2 直接填入 nums1 後方的空位，然後對整個 nums1 進行排序。

* **缺點**：排序的時間複雜度通常為 $O((m+n) \\log(m+n))$，沒有利用到「兩個陣列已排序」的特性。

### **正向雙指標**

使用兩個指標分別指向 nums1 和 nums2 的起點，比較後放入新陣列。

* **缺點**：由於題目要求 **原地修改**，若從前往後放，會覆蓋 nums1 原有的元素，必須先複製一份 nums1 的有效元素，這會導致額外的 $O(m)$ 空間。

### **優化思路：逆向雙指標（最優解）**

既然 nums1 的後方有空位，我們應該從 **最大值** 開始考慮：

1. **指標設定**：  
   * 指標 p1 指向 nums1 的有效結尾（索引 m \- 1）。  
   * 指標 p2 指向 nums2 的有效結尾（索引 n \- 1）。  
   * 指標 p 指向 nums1 的最終結尾（索引 m \+ n \- 1）。  
2. **比較邏輯**：  
   * 比較 nums1\[p1\] 與 nums2\[p2\]，將較大者放入 nums1\[p\]。  
   * 移動相應的指標（p 和選中的 p1 或 p2）。  
3. **邊界處理**：  
   * 若 nums2 還有剩餘，需全部補入 nums1（因為 nums1 原有的剩餘部分本來就在正確位置，不需處理）。

## **4\. 解法分析**

\# 複雜度分析：  
\# 時間複雜度：O(m \+ n)，僅需遍歷兩個陣列一次。  
\# 空間複雜度：O(1)，直接在 nums1 上操作，不需額外空間。

## **5\. 總結**

本題的關鍵在於 **「從後往前」**。這個技巧在處理有空間緩衝區的陣列合併問題時非常常見，能有效避免數據覆蓋與不必要的數據位移。
