# **LeetCode 141\. Linked List Cycle 知識統整**

## **1\. 題目敘述 (Problem Description)**

給定一個鏈結串列（Linked List）的 head，判斷該串列中是否存在「環」（Cycle）。

* **環的定義**：如果鏈結串列中某個節點可以透過持續追蹤 next 指標再次被到達，則該串列存在環。  
* **輸入**：head（鏈結串列的首節點）。  
* **輸出**：true（有環）或 false（無環）。  
* **注意**：在 LeetCode 的系統內部會使用 pos 來表示尾部連接到的節點索引，但 pos 不會作為參數傳遞給你的函數。

## **2\. 測驗目的 (Test Objectives)**

這道題目主要考察以下幾點能力：

1. **鏈結串列基本操作**：熟悉如何遍歷 Linked List。  
2. **空間與時間複雜度的權衡**：理解如何從 $O(n)$ 空間複雜度優化到 $O(1)$。  
3. **雙指標技巧 (Two Pointers)**：特別是「快慢指標」在偵測循環中的經典應用。  
   * **聯想思路**：當我們面對「線性結構中是否存在循環」的問題時，最直覺的物理模型就是「操場跑步」。如果兩個人在直線上跑，速度快的人永遠不會再見到速度慢的人；但在環形跑道上，速度快的人遲早會「套圈」慢的人。這種「相對速度」產生的距離縮減，是解決環形問題的核心直覺。  
   * **為什麼可以這樣做？**：這基於數學上的 **Floyd 判圈算法**。當進入環後，快指標與慢指標的距離每一步都會縮短 1 個單位（$2 \- 1 \= 1$）。只要環存在，兩者的距離終將歸零（相遇），而不會發生跳過（Skip）的情況。  
   * **具體作法**：初始化兩個指標指向 head。在迴圈中，慢指標每次移動 1 格，快指標每次移動 2 格。如果快指標碰到 null，說明無環；如果兩者指標相等，則說明有環。  
     * 深入探討：為什麼步長是 1 和 2？可以用 m 和 n 嗎？  
       理論上只要 $n \> m \\ge 1$，在有環的情況下快慢指標最終都會相遇。但選擇 $m=1, n=2$ 是最優解，原因如下：  
       1. **防止「跳過」**：當相對速度為 1（即 $2 \- 1$）時，快指標相對於慢指標每回合只靠近 1 格。這保證了它們在環中一定會「踩在同一個節點上」而相遇。如果相對速度大於 1（例如 $m=1, n=3$），在某些離散的節點結構中，快指標有可能在某一回合剛好「跨過」了慢指標而沒有在同一點重合，雖然在多次循環後最終仍會相遇，但邏輯判斷上相對速度為 1 最為穩健。  
       2. **效率考量**：較大的步長會導致快指標更快地在環內空轉，且在判斷 fast.next.next 時需要處理更多邊界檢查（Null Check），增加程式碼複雜度。  
       3. 最壞情況優化（第一圈必相遇證明）：  
          當慢指標（Slow）剛進入環的那一刻，快指標（Fast）已經在環內某處了。  
          * 假設環的長度為 $L$。  
          * 此時快指標與慢指標在環內的距離為 $D$（$0 \\le D \< L$）。  
          * 因為快指標比慢指標每步快 1 格，所以每走一步，兩者的距離就縮減 1。  
          * 追上彼此所需的步數即為 $D$ 步。  
          * 由於 $D \< L$，而慢指標走完一圈需要 $L$ 步，因此在慢指標走完第一圈（$L$ 步）之前，快指標一定已經走了 $D$ 步並與之相遇。這保證了時間複雜度穩定保持在 $O(n)$。  
   * **背後原因**：這種做法最大的優勢在於**空間效率**。它不需要像雜湊表那樣額外記錄每個節點的地址，僅利用兩個變量（指標）即可完成驗證，達成 $O(1)$ 的空間複雜度。

## **3\. 思路邏輯 (Logic & Reasoning)**

當我們在一個有環的跑道上跑時，如果我們一直跑下去，我們一定會「回到曾經跑過的地方」。基於這個特性，我們可以演化出兩種邏輯：

### **邏輯 A：記住走過的路 (Hash Table)**

我們每走到一個節點，就把這個節點的地址（記憶體位置）記錄下來。如果某個節點的 next 指向了一個「已經記錄過」的節點，那就代表有環。

### **邏輯 B：速度差追趕 (Floyd's Cycle-Finding Algorithm)**

想像兩個人在圓形操場跑步，A 的速度快，B 的速度慢。只要時間夠長，快的人一定會「領先一圈」並從後面追上慢的人。如果串列沒有環，快的人會先到達終點（null）。

## **4\. 解法說明 (Solutions)**

### **解法一：雜湊表 (Hash Table)**
使用一個 Set 來儲存所有訪問過的節點。

* **時間複雜度**：$O(n)$，每個節點訪問一次。  
* **空間複雜度**：$O(n)$，最差情況下需要存入所有節點。


### **解法二：快慢指標 (Floyd's Tortoise and Hare) \- 推薦解法**
定義兩個指標 slow（每次走一步）和 fast（每次走兩步）。

* **時間複雜度**：$O(n)$。  
* **空間複雜度**：$O(1)$，僅需額外兩個指標，這是本題最優解。

## **5\. 總結比較**

| 特性 | 雜湊表法 (Hash Table) | 快慢指標法 (Two Pointers) |
| :---- | :---- | :---- |
| **直觀程度** | 高 | 中 |
| **空間消耗** | $O(n)$ | $O(1)$ |
| **適用場景** | 記憶體充足且追求代碼易讀 | 記憶體受限或追求極致性能 |

