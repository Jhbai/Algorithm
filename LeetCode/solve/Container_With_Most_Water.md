# **LeetCode 11: Container With Most Water 深度解析**

這道題目是 LeetCode 中非常經典的陣列與指標應用題，主要考查如何優化暴力搜索的效率。

## **1\. 題目敘述 (Problem Description)**

給定一個長度為 $n$ 的整數陣列 height。每個元素 height\[i\] 代表在座標 $(i, 0)$ 到 $(i, height\[i\])$ 之間繪製的一條垂直線。

目標： 找出其中的兩條線，與 $x$ 軸共同構成一個容器，使得這個容器能容納最多的水。  
注意： 你不能傾斜容器，且返回的值應為該容器的最大盛水量（面積）。

### **範例**

* **輸入：** height \= \[1,8,6,2,5,4,8,3,7\]  
* **輸出：** 49  
* **解釋：** 圖中由索引 1 (高度 8\) 與索引 8 (高度 7\) 構成的容器面積最大，計算方式為：$$\\text{Area} \= \\min(8, 7\) \\times (8 \- 1\) \= 7 \\times 7 \= 49$$

## **2\. 測驗目的**

這題的核心目的在於測驗面試者是否具備以下能力：

* **雙指標 (Two Pointers) 技術：** 這是解決陣列區間問題的常用且高效的手法。  
  * **為什麼本題與雙指標有關？** 由於容器的面積由「寬度」與「高度」共同決定，而寬度是由陣列中兩個元素的「索引距離」定義的。使用雙指標從陣列的兩端向中間移動，可以讓我們從「最大寬度」開始縮小範圍。透過指標的移動邏輯（移動較矮的一方），我們能確保在縮小寬度的同時，有機會找到更高的壁壘來增加高度，進而遍歷所有可能產生最大面積的區間組合，將原本 $O(n^2)$ 的暴力搜尋優化至 $O(n)$。  
  * **如何判斷題目適用雙指標？** 當題目具備以下特徵時，通常可以優先考慮雙指標解法：  
    1. **線性結構：** 處理對象為數組（Array）、字串（String）或鏈表（Linked List）。  
    2. **區間尋找：** 需要尋找符合特定條件的一個區間、一對數值或子序列。  
    3. **有序性或可優化搜尋：** 題目具備某種單調性（例如排序後、或是寬度遞減時的性質），使得我們不需要遍歷所有組合（暴力解），而是可以透過縮減搜尋空間來達成目標。  
* **邏輯推理與優化：** 題目若使用暴力解法（遍歷所有組合）的時間複雜度為 $O(n^2)$，但在 $n$ 很大時會超時，因此需要思考如何利用題目特性（木桶效應）來進行剪枝或優化。  
  * 什麼是木桶效應 (Cannikin Law)？ 木桶效應是指「一只木桶能裝多少水，並不取決於最長的那塊木板，而是取決於最短的那塊」。  
    在本題中，容器的「高度」是由左右兩條線中較短的那一條決定的。這意義著：  
    1. 即使其中一邊非常高（例如 100），但如果另一邊只有 1，那麼高度依然只能計為 1。  
    2. 如果我們移動「較長」的那一邊，容器的有效高度只會維持現狀或變低（受限於沒動的那條短邊），而寬度卻必然減少，所以面積一定會變小。  
    3. 只有移動「較短」的那一邊，我們才有機會遇到比當前短邊更高的線，從而提升容器的整體高度，這也是為什麼我們可以略過許多無效組合的原因。  
* **理解「貪心算法 (Greedy)」：** 在每一步選擇中，如何決定移動哪一個指標以保證不漏掉評在的最大值。

## **3\. 思路邏輯與推導**

要計算容器的面積，公式為：

$$\\text{Area} \= \\text{寬度} \\times \\text{高度} \= (\\text{right} \- \\text{left}) \\times \\min(\\text{height\[left\]}, \\text{height\[right\]})$$

### **關鍵點：木桶效應**

容器的盛水量取決於**較短的那一邊**。

### **如何移動指標？**

1. **初始狀態：** 我們將兩個指標分別指向陣列的最左端 (left \= 0\) 與最右端 (right \= n \- 1)。此時「寬度」是最大的。  
2. **移動邏輯：** 為了尋找更大的面積，我們必須收縮指標。  
   * 如果我們移動「較高」的那一邊，寬度變小了，但受限於原有的短板，面積肯定不會增加。  
   * 如果我們移動「較矮」的那一邊，雖然寬度變小，但我們有機會遇到一個更高的壁壘，從而補償寬度變小的損失。  
3. **結論：** 每次迭代時，比較左右指標的高度，**移動較短的那一側指標**。  
4. **執行次數與終止條件：** 這個「找較短一側指標並移動」的過程會持續執行，直到 **left 指標與 right 指標相遇（即 left \== right）** 為止。在總長度為 $n$ 的陣列中，這個操作最多執行 $n-1$ **次**。這是因為每個步驟都會讓兩個指標之間的距離縮短 1，而我們從距離 $n-1$ 開始，直到距離變為 0。  
5. 如果兩邊一樣高，該移動哪一邊？  
   當 height\[left\] \== height\[right\] 時，其實移動左邊或右邊都可以，結果是一樣的。  
   * **理由：** 因為面積受限於「短板」，當兩邊等高時，兩邊同時都是短板。如果你只移動其中一邊，寬度減少了，且新高度最多只能等於或小於另一邊沒動的高度。  
   * **結論：** 只要兩邊等高，目前的面積已經是這組指標範圍內的潛在最大值，為了尋找下一個可能的突破，你必須換掉其中一個（或兩個）邊界。在程式實作中，我們通常簡單地併入 else 邏輯中，讓其中一個指標移動即可。

## **4\. 解法實現 (Solution)**

以下提供 Python 的解法實作，具備最優的 $O(n)$ 時間複雜度。

def maxArea(height):  
    \# 初始化左右雙指標  
    left \= 0  
    right \= len(height) \- 1  
    max\_val \= 0  
      
    \# 當左指標小於右指標時持續進行  
    while left \< right:  
        \# 計算當前寬度  
        width \= right \- left  
        \# 計算當前高度 (取兩者中較矮的一方)  
        current\_h \= min(height\[left\], height\[right\])  
          
        \# 更新最大面積  
        current\_area \= width \* current\_h  
        if current\_area \> max\_val:  
            max\_val \= current\_area  
              
        \# 核心邏輯：移動較短的那一方  
        \# 若左邊較短，移動左指標；若右邊較短或兩邊等高，移動右指標  
        if height\[left\] \< height\[right\]:  
            left \+= 1  
        else:  
            right \-= 1  
              
    return max\_val

### **複雜度分析**

* **時間複雜度：** $O(n)$，因為左右指標總共只會遍歷陣列一次。  
* **空間複雜度：** $O(1)$，僅使用了常數空間來儲存指標與最大值。
