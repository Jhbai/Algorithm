# **LeetCode 287\. Find the Duplicate Number 深度解析**

這道題目在演算法面試中非常經典，它不僅考察對數組與鏈結列表轉換的理解，更挑戰了在嚴格限制（不可修改原數組、僅限常數空間）下的優化思維。

## **1\. 題目敘述 (Problem Description)**

給定一個含有 $n \+ 1$ 個整數的數組 nums，其數字都在 $1$ 到 $n$ 之間（包含 $1$ 與 $n$）。  
根據「鴿巢原理」（Pigeonhole Principle），這個數組中至少會有一個重複的數字。  
**題目要求：**

* 找出這個重複的數字。  
* **限制條件：**  
  1. 不得修改原數組（假設數組是唯讀的）。  
  2. 只能使用 $O(1)$ 的額外空間（常數空間）。  
  3. 時間複雜度應小於 $O(n^2)$。  
  4. 雖然只有一個重複的數字，但該數字可能出現兩次以上。

### **「鴿巢原理」？ (Pigeonhole Principle?)**

鴿巢原理（又稱抽屜原理）是一個簡單但強大的組合數學概念。其核心描述為：

若有 $n$ 個鴿籠，但有 $n \+ 1$ 隻鴿子要住進去，那麼至少有一個鴿籠裡會住著兩隻或更多的鴿子。

與本題的關係：  
在本題中，我們可以將「數值」視為鴿子，將「可選範圍（$1$ 到 $n$）」視為鴿籠：

* **鴿籠（可能的值）：** 數字範圍是 $1, 2, \\dots, n$，總共有 $n$ 個可能的數值。  
* **鴿子（實際的數字）：** 數組 nums 的長度為 $n \+ 1$，表示總共有 $n \+ 1$ 個元素。  
* **結論：** 當我們試圖將 $n \+ 1$ 個元素放入只有 $n$ 種選擇的空間時，根據原理，絕對會出現至少一個重複的數字。這保證了題目給定的條件下，答案一定存在。

## **2\. 測驗目的 (Objectives)**

這題的主要目的在於考察開發者是否能跳脫「直覺解法」的框架：

* **空間效率：** 禁止使用雜湊表（Hash Set），強迫思考位元運算或指標技巧。  
  * **位元運算 (Bit Manipulation)：** 在軟體演算法中，這主要是利用「逐位統計」的概念。我們可以統計數組中所有數字在第 $i$ 個位元（bit）出現 $1$ 的次數，並與標準 $1$ 到 $n$ 序列中該位元應出現 $1$ 的次數做比較。如果數組的統計值較大，說明重複數字在該位元必為 $1$。  
    * **注意與硬體實作的區別：** 在真實的數位電路（如 ALU 或專門的硬體電路）中，這類需求通常會透過「比較器網路」或「內容定址記憶體 (CAM)」來實現並行處理，而非像軟體一樣逐位迭代計數。此處的位元運算是為了在 $O(1)$ 空間限制下，利用二進制特性來推導結果。  
  * **指標技巧 (Pointer Techniques)：** 此處指「快慢指標」或「雙指標」。核心在於利用數組索引（Index）與數值（Value）之間的映射關係，將數組視為一個隱含的「單向鏈結列表（Linked List）」，進而轉換成偵測環路的問題。  
* **數據變更：** 禁止原地修改（例如將數字變為負數標記），強迫思考非破壞性的查找演算法。  
* **抽象轉換：** 考察是否能將「數組索引與數值的映射」抽象化為「鏈結列表（Linked List）」中的環檢測問題。

## **3\. 思路邏輯與分析 (Intuition & Logic)**

從題目敘述中，我們可以推導出以下關鍵點：

1. **值域與索引的關係：** 數組長度為 $n+1$，數字範圍是 $\[1, n\]$。這意味著每個數值都可以作為一個「索引」指向下一個位置，且絕對不會越界（因為最大值 $n$ 剛好是最後一個索引範圍內）。  
2. **重複即「環」：** 如果有一個數字重複出現（例如數字 2 出現在不同位置），這代表有兩個不同的「點」都指向同一個「點」。在圖論或鏈結列表的概念中，這必然會形成一個 **環（Cycle）**。  
3. **二分搜尋的可行性：** 雖然數組無序，但「值域」 $\[1, n\]$ 是有序的. 我們可以針對「數值的範圍」進行二分搜尋，利用計數來判斷重複區間。

## **4\. 解法統整 (Solutions)**

### **解法一：快慢指標（Floyd's Cycle-Finding Algorithm）**

這是本題最優解（$O(n)$ 時間，$O(1)$ 空間）。將數組看作一個鏈結列表，nums\[i\] 代表節點 i 指向的下一個節點。

**具體尋找步驟：**

1. **第一階段：找環中的相遇點**  
   * 設置兩個指標 slow 和 fast，初始值都指向 nums\[0\]。  
   * 進入循環：slow 每次前進一步（slow \= nums\[slow\]），fast 每次前進兩步（fast \= nums\[nums\[fast\]\]）。  
   * 因為數組中存在重複數字（即環），快指標最終一定會追上慢指標，兩者在環中的某個位置相遇。  
2. **第二階段：鎖定環入口（重複數字）**  
   * 當兩指標相遇時，將 slow 指標重新指向起點 nums\[0\]。  
   * fast 指標維持在相遇點不動。  
   * 接著讓 slow 和 fast 同時前進，但這次兩者都 **只前進一步**。  
   * 當它們再次相遇時，該相遇點所代表的數值就是環的入口，也就是我們在尋找的 **重複數字**。

#### **為什麼要這樣找？（核心邏輯與思考路徑）**

這部分的思考邏輯是基於「路徑差」的數學補償：

* 聯想：操場賽跑  
  想像你在操場（環）跑步，如果你比別人慢，別人在超你一圈時會與你相遇。但「相遇的地點」並不一定是「進入操場的入口」。  
* **數學推導：**  
  * 設「起點到環入口」的距離為 $a$。  
  * 設「環入口到相遇點」的距離為 $b$。  
  * 設「整個環的周長」為 $L$。  
  * 當相遇時：  
    * 慢指標走了：$a \+ b$  
    * 快指標走了：$a \+ b \+ kL$ （$k$ 為繞環圈數）  
  * 因為快指標速度是慢指標的兩倍：$2(a \+ b) \= a \+ b \+ kL$  
  * 簡化後得到：$a \+ b \= kL$ $\\rightarrow$ $a \= kL \- b$  
* 結論的直覺解釋：  
  $a \= kL \- b$ 這個等式告訴我們：「從起點走到入口的距離 ($a$)」，剛好等於「從相遇點繼續往前走完剩下的環回到入口的距離 ($kL \- b$)」。  
* 為什麼第二階段改為各走一步？  
  在第一階段，我們需要快指標走兩步是為了「製造速度差」來偵測環的存在。但在第二階段，我們的目的不再是偵測環，而是要 「同步測量距離」。  
  根據公式 $a \= kL \- b$，我們知道「起點到入口」與「相遇點到入口」這兩段路程在 步數上是相等的（或是差了整數倍的環長）。如果此時快指標還走兩步，就會破壞這個步數的對稱性，導致兩者錯過。  
* 為什麼這樣一定會相遇？  
  因為我們已經透過數學證明了距離相等。想像兩個人從兩個不同的起跑點（一個在 nums\[0\]，一個在 相遇點）出發，他們的目的地都是 環入口。既然他們前進的速度相同（都走一步），且到目的地的距離也相同，那麼他們踏入目的地的那一刻，必然會站在同一個位置。  
* 如何聯想？  
  當你發現自己在環中迷路（相遇點）時，你不知道入口在哪，但你知道「起點到入口」與「當前點到入口」的剩餘步數是對稱的。因此，將一個指標歸零，另一個留在原地，兩者以同樣速度前進，就像是在進行一場「距離校準」，最後交匯處必然是那個結構上的奇點——入口（重複數字）。
