# **LeetCode 438\. Find All Anagrams in a String 深度解析**

本篇文件將針對 LeetCode 第 438 題進行全面的剖析，從題目理解到高效演算法的實現，幫助讀者掌握處理字串子串問題的核心技巧。

## **1\. 題目敘述 (Problem Description)**

給定兩個字串 s 和 p，請找出 s 中所有是 p 的 **字母異位詞 (Anagram)** 的子串，並返回這些子串的 **起始索引**。你可以按任何順序返回答案。

**字母異位詞** 的定義：由相同字母組成，但排列順序可能不同的字串。

### **範例：**

* **輸入:** s \= "cbaebabacd", p \= "abc"  
* **輸出:** \[0, 6\]  
* **解釋:** \* 索引 0 的子串是 "cba"，它是 "abc" 的異位詞。  
  * 索引 6 的子串是 "bac"，它是 "abc" 的異位詞。

## **2\. 測驗目的與核心考點**

這道題目在技術面試中非常經典，主要考察候選人對於以下概念的掌握程度：

1. **滑動視窗 (Sliding Window)**：如何高效地在長字串中維護一個固定長度的視窗。  
2. **雜湊表/頻率統計 (Hash Map / Frequency Array)**：如何判斷兩個字串是否為異位詞（即字元種類與數量是否完全一致）。  
3. **時間複雜度優化**：避免使用 $O(N \\times K)$ 的暴力解法（其中 $K$ 為 p 的長度），轉而追求 $O(N)$ 的線性時間複雜度。

### **如何聯想到優化解法？**

當我們面對「在長字串中尋找特定模式的子串」時，思考路徑通常如下：

* **暴力直覺**：檢查每一個長度為 $K$ 的子串。這需要 $N-K$ 次檢查，每次檢查（比對字元頻率）需要 $O(K)$，總共 $O(N \\times K)$。  
* **發現冗餘**：當視窗從 i 移動到 i+1 時，中間有 $K-1$ 個字元是重疊的。暴力法卻把這 $K-1$ 個字元重新數了一次。  
* **空間換時間**：既然中間的字元沒變，我們只需要處理「離開」的一個字元和「進入」的一個字元。這種「增量更新」的思想就是**滑動視窗**的精髓，能將每次移動的複雜度從 $O(K)$ 降至 $O(1)$。

## **3\. 思路邏輯分析**

### **關鍵觀察**

* **固定長度**：任何 p 的異位詞在 s 中形成的子串，長度必然等於 p.length()。  
* **等價性判斷**：要判斷兩個長度相同的字串是否互為異位詞，最快的方法是檢查它們的「字元計數器」是否相同。

### **邏輯步驟**

1. **初始化計數器**：先統計字串 p 中每個字元出現的次數。  
2. **建立視窗**：在 s 中取前 p.length() 個字元建立第一個視窗，並統計其計數。  
3. **比較與滑動**：  
   * 如果目前視窗的計數等於 p 的計數，記錄起始索引。  
   * 將視窗向右移動一格：**加入**右邊新進入的一個字元，並**移除**左邊離開的一個字元。  
   * 重複此過程直到遍歷完字串 s。

## **4\. 高效解法：滑動視窗 (Sliding Window)**

我們可以使用一個長度為 26 的整數陣列來充當雜湊表（因為題目註明僅含小寫英文字母），這樣比使用 Map 更快且更節省空間。

### **複雜度分析**

* **時間複雜度**：$O(N)$。我們只遍歷了字串 s 一次，雖然每次移動都會比較計數陣列，但陣列大小固定為 26，比較時間為常數級別。  
* **空間複雜度**：$O(1)$。除了結果陣列外，我們只使用了固定大小（26）的計數陣列。

## **5\. 常見錯誤與注意事項**

* **邊界條件**：務必檢查 len(s) \< len(p) 的情況。  
* **視窗更新**：滑動視窗時，必須同時執行「右進」與「左出」，否則視窗長度會錯誤。  
* **大小寫**：本題限制小寫字母，若有大寫或特殊符號，需將計數陣列擴大或改用 Hash Map。
